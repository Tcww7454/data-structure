#include<iostream>
#include<string>

using namespace std;
//kmp中，并不对母串指针进行回溯，只对模式串的指针进行回溯
/*
    在该程序中，将母串标识为A串，将模式串标识为B串

    当A子串的后缀集合与B子串的前缀集合有交集时，将B串后移的该串才与A串的对应位置有可能匹配
    eg:
    A:abababaababacb
    B:ababacb
    取第一次匹配失败进行模拟，发现A前5个字符的后缀（长度为3）的abc与B子串的前3个字符的前缀相同

    需要注意的是，在i处匹配失败，是意味在前i-1个字符匹配成功的，也就是说A是存在与B的子串完全相同的一个子串的
    而kmp的移动一开始应该是看A串与B串匹配成功的最长子串的，也就是A子串的后缀集合与B子串的前缀集合的交集

    为什么，因为匹配成功意味着现在存在着能够完全对应的A子串和B子串，但现在的匹配头（A串指针位置）并不能让其完全匹配。
    因此此时就需要移动子串的位置，让其重新开始匹配，但是如果暴力匹配的话其实是忽略子串中已经匹配成功了的串的信息了，
    而kmp就是把这个暴力没有利用到的信息利用起来，而利用方式就是通过已经匹配成功的A子串和B子串的最长公共前后缀进行的
    这里的A子串是用到后缀，B子串用的是前缀，因为这里需要我们将B子串往后移动，用A的前缀B的后缀没有意义，
    当我们能够找到A子串的所有前缀与B子串的所有后缀中匹配的最长情况时，我们就能找到能将B子串往后移动的长度

    而需要注意的是，我们这里此时用的是A子串的后缀集合与B子串的点缀集合的交集的最长。
    而这里我们用到A子串和B子串其实是已经匹配过的，就是说已经是完全一样的，故我们就可以把其转换为B子串中对应后缀集合
    与前缀集合的交集，要使效率最高，这里应该去交集中集合最大的串的长度

    故这里可以推出：j指针（B串的匹配位置）=B子串的最长公共前后缀（这里是发生以失佩的前一个字母为截断位置的B子串的最长公共前后缀）

    这里可以总结：j指针回溯的位置就只与B串有关，与A串无关，这里是因为一个等效过来的

    故这就是为什么next数组是只需要B串即可构建的原因，其实是因为A串鱿鱼匹配可以等效为B子串

    next数组与B串形成映射数组，存的数据next[i]就是B[1]~B[i]的最长公共前后缀的长度


*/

//next数组中数值含义：在匹配失败时，我们可以跳过匹配的字符个数

//构建next数组
/*
    让B串自己与自己匹配
    b[i]~b[i]与它的后缀匹配，后缀为主串(A串)，前缀为模式串(B串)
    通过递推求出next数组
*/

int *kmp_next(string&s)
{
    int k=0,i,n=s.length(),*next=new int[n];
    next[0]=-1;//此时是一个没有字符匹配的情况，此时应该将i指针+1
    for(int i=1;i<n;i++)
    {
        next[i]=k;
        while(k!=-1&&s[i]!=s[k])k=next[k];
        k++;
    }
    return next;
}


int kmp_index(string&a,string&b)
{
    int i,j;
    int *b_next=kmp_next(b);
    int n=a.length();
    for(i=j=0;i<=n;i++,j++)
    {
        if(j==b.length()){//匹配到了模式串底部,已经成功匹配，返回
            delete[]b_next;
            return i-j;
        }
        while(j!=-1&&a[i]!=b[j])//失配时对j指针进行回溯
        {
            j=b_next[j];
        }
    }
    delete[]b_next;
    return -1;

}

int main()
{
    string a="ababababcababababc";
    int *next=kmp_next(a);

    for(int i=0;i<a.length();i++)
    cout<<next[i]<<"\t";
   

    string b="abc";
    cout<<endl<<kmp_index(a,b)<<endl;

    return 0;
}